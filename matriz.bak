#ifndef __MATRIZ_H__
#define __MATRIZ_H__

#include <math.h>
#include <stdlib.h>
#include <string.h>

#define TYPE GLdouble
typedef struct {
    TYPE **data;
    int d1, d2; // d1 => linhas; d2 => colunas;
} Matriz;

Matriz *CriarMatriz(int d1, int d2) {
    int i;
    Matriz *n = (Matriz *) malloc(sizeof(Matriz));
    n->data = (TYPE **) malloc(d1*sizeof(TYPE*));
    for (i = 0; i < d1; i++)
        n->data[i] = (TYPE *) malloc(d2*sizeof(TYPE));
    n->d1 = d1;
    n->d2 = d2;
    return n;
}

void LiberarMatriz(Matriz **M) {
    int i;
    Matriz *ref = *M;
    for (i = 0; i < ref->d1; i++)
        free(ref->data[i]);
    free(ref->data);
    free(ref);
    *M = NULL;
}

void ImprimirMatriz(Matriz *M) {
    int i, j;
    for (i = 0; i < M->d1; ++i) {
        for (j = 0; j < M->d2; ++j)
            printf(" %d", M->data[i][j]);
        printf("\n");
    }
    printf("\n");
}

Matriz *CopiarMatriz(Matriz *A) {
    int i, j;
    Matriz *R = NULL;
    if (A != NULL) {
        R = CriarMatriz(A->d1, A->d2);
        for (i = 0; i < A->d1; i++)
            for (j = 0; j < A->d2; j++)
                R->data[i][j] = A->data[i][j];
    }
    return R;
}


int MatrizesIguais(Matriz *A, Matriz *B) {
    if (A->d1 != B->d1) return 0;
    if (A->d2 != B->d2) return 0;

    int i, j;
    for (i = 0; i < A->d1; ++i)
        for (j = 0; j < A->d2; ++j)
            if (A->data[i][j] != B->data[i][j])
                return 0;
    return 1;
}

// Matriz *CriarMatrizPorArray(TYPE *array) {
//     int n = sizeof(array);
//     Matriz *R = CriarMatriz(1, n);
//     strcpy(R->data[0], array);
//     return R;
// }

// if ((i < 0) || (i >= m->d1)
//  || (j < 0) || (J >= m->d2))
// #define Def(M, i, j) (M->data[i*M->d1 + j])

Matriz *CriarZero(int d1, int d2) {
    int i, j;
    Matriz *Zero = CriarMatriz(d1, d2);
    for (i = 0; i < d1; i++)
        for (j = 0; j < d2; ++j)
            Zero->data[i][j] = 0;
    return Zero;
}

Matriz *CriarIdentidade(int dim) {
    int i, j;
    Matriz *Ident = CriarMatriz(dim, dim);
    for (i = 0; i < dim; i++)
        for (j = 0; j < dim; ++j)
            if (i == j) Ident->data[i][j] = 1;
            else        Ident->data[i][j] = 0;
    return Ident;
}

Matriz *Somar(Matriz *A, Matriz *B) {
    int i, j;
    Matriz *C = NULL;
    if (A != NULL && B != NULL) {
        if (A->d1 == B->d1 && A->d2 == B->d2) {
            C = CriarMatriz(A->d1, A->d2);
            for (i = 0; i < A->d1; i++)
                for (j = 0; j < A->d2; j++)
                    C->data[i][j] = A->data[i][j] + B->data[i][j];
        }
    }
    return C;
}

Matriz *Oposto(Matriz *A) {
    int i, j;
    Matriz *R = NULL;
    if (A != NULL) {
        R = CriarMatriz(A->d1, A->d2);
        for (i = 0; i < A->d1; i++)
            for (j = 0; j < A->d2; j++)
                R->data[i][j] = -A->data[i][j];
    }
    return R;
}

Matriz *Subtrair(Matriz *A, Matriz *B) {
    return Somar(A, Oposto(B));
}

Matriz *Multiplicar(Matriz *A, Matriz *B) {
    int i, j, k;
    Matriz *C = NULL;
    if (A != NULL && B != NULL) {
        // A (a x k)
        // B (k x b)
        if (A->d2 == B->d1) {
        // C (a x b)
            C = CriarZero(A->d1, B->d2);

            for (i = 0; i < C->d1; i++)
                for (j = 0; j < C->d2; j++)
                    for (k = 0; k < A->d2; k++)
//                  for (k = 0; k < B->d1; k++)
                        C->data[i][j] += A->data[i][k] * B->data[k][j];
        }
    }
    return C;
}

Matriz *Zn(Matriz *A, int n) {
    int i, j;
    Matriz *C = NULL;
    if (A != NULL) {
        C = CriarMatriz(A->d1, A->d2);
        for (i = 0; i < A->d1; i++)
            for (j = 0; j < A->d2; j++)
                C->data[i][j] = abs(A->data[i][j]) % n;
    }
    return C;
}

Matriz *OpostoZn(Matriz *A, int n) {
    return Zn(Oposto(A), n);
}

Matriz *SomarZn(Matriz *A, Matriz *B, int n) {
    return Zn(Somar(A, B), n);
}

Matriz *SubtrairZn(Matriz *A, Matriz *B, int n) {
    return Zn(Subtrair(A, B), n);
}

Matriz *MultiplicarZn(Matriz *A, Matriz *B, int n) {
    return Zn(Multiplicar(A, B), n);
}

Matriz *Transpor(Matriz *A) {
    int i, j;
    Matriz *At = NULL;
    if (A != NULL) {
        At = CriarMatriz(A->d2, A->d1);
        for (i = 0; i < A->d1; i++)
            for (j = 0; j < A->d2; j++)
                At->data[j][i] = A->data[i][j];
    }

    return At;
}

Matriz *ConcatenarH(Matriz *A, Matriz *B) {
    int i, j;
    Matriz *C = NULL;
    if (A != NULL && B != NULL) {
        if (A->d1 == B->d1) {
            C = CriarMatriz(A->d1, A->d2 + B->d2);
            for (i = 0; i < A->d1; i++) {
                for (j = 0; j < A->d2; j++)
                    C->data[i][j] = A->data[i][j];
                for (j = A->d2; j < C->d2; j++)
                    C->data[i][j] =  B->data[i][j - A->d2];
            }
        }
    }
    return C;
}

#endif // __MATRIZ_H__
